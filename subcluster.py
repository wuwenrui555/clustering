from pydantic import BaseModel, Field
from pathlib import Path
from typing import Union, Dict, Any
import pandas as pd
import uuid


# 1. clustering_sequence: record the sequence of clustering
# uuid_1, uuid_2, uuid_3, ...

# 2. clustering_result:
# Necessary fields:
# (1) clustering_id (uuid)
# (2) unit_id: id of the unit included in the clustering
# (3) cluster_id: id of the cluster assigned to the unit
# Optional fields:
# (4) annotation: annotation for the cluster (used for explicit clusters)
# (5) tag: tag for the cluster (used for non-explicit clusters)


# 3. cluster_id_manager:
# (1) unit_id: id of the unit included in the clustering
# (2) clustering results: one column for each clustering result, column name is
# the clustering id, value is the cluster id. Arrange the columns in the order of
# clustering_sequence.
# (3) latest_cluster_id: the latest cluster id for each unit, generated by
# concatenating the all cluster ids in the order of clustering_sequence.

# 4. cluster_labels_manager:
# (1) unit_id: id of the unit included in the clustering
# (2) annotation: annotation for the cluster (used for explicit clusters)
# (3) tag: tag for the cluster (used for non-explicit clusters)

# 5. summary: cluster_id_manager and cluster_label_manager
# (1) unit_id: id of the unit included in the clustering
# (2) clustering results: the clustering results of the unit, arranged in the
# order of clustering_sequence.
# (3) latest_cluster_id: the latest cluster id for each unit, generated by
# concatenating the all cluster ids in the order of clustering_sequence.
# (4) annotation: annotation for the latest cluster id (used for explicit clusters)
# (5) tag: tag for the latest cluster id (used for non-explicit clusters)


# File structure:
# output_dir/
#   clustering_sequence.txt: the sequence of clustering ids
#   clustering results/:
#     clustering_id_1.csv: the clustering result of the first clustering (unit_id,
#     cluster_id, annotation, tab_1, tab_2, ...)
#     clustering_id_2.csv: the clustering result of the second clustering

# Workflow:
# 1. Load the raw data (unit_id as row index, feature as column index)
# 2. Initialize the clustering result manager, load the clustering results from
#    the output_dir and map the cluster information to the raw data.
# 3. Subset the raw data based on the cluster information and perform subclustering.
# 4. Export the subclustering results to the output_dir.
# 5. Repeat the same workflow for the subclustering results.


class ClusteringResult(BaseModel):
    """
    A class to record the result of clustering and manage the annotation and tag.

    Attributes:
    -----------
    unit_id: list[str]
        The id of each unit included in the clustering.
    cluster_id: list[str]
        The cluster id assigned to each unit.
    clustering_id: str
        The id of the clustering.
    cluster_df: pd.DataFrame
        DataFrame to record the clustering result:
        - clustering_id: the id of the clustering process.
        - cell_id: the id of the unit.
        - cluster_id: the cluster id assigned to the unit.
        - annotation: the annotation for each cluster. If not specified, the
        cluster is non-explicit.
        - tag: the tag for each cluster. It is recommended to specify the tag for
        clusters with non-explicit annotation (mixed annotations), which makes it
        easier to select the non-explicit clusters for next clustering.
    """

    unit_id: list[str]
    cluster_id: list[str]
    clustering_id: str
    cluster_df: pd.DataFrame = Field(default_factory=pd.DataFrame)

    model_config = {"arbitrary_types_allowed": True}

    def __init__(self, **data):
        super().__init__(**data)
        self.cluster_df = pd.DataFrame(
            {
                "clustering_id": self.clustering_id,
                "unit_id": self.unit_id,
                "cluster_id": self.cluster_id,
            }
        )

    def add_annotation(self, annotation: dict[str, str]):
        """
        Add annotation to explicit clusters.

        Parameters:
        -----------
        annotation: dict[str, str]
            The annotation for each cluster with key as the cluster id and value as the annotation.
        """
        # Create a mapping from cluster_id to annotation
        cluster_to_annotation = {}
        for cluster_id in self.cluster_df["cluster_id"].unique():
            cluster_to_annotation[cluster_id] = annotation.get(cluster_id, "")

        # Add the annotation column
        self.cluster_df["annotation"] = self.cluster_df["cluster_id"].map(
            cluster_to_annotation
        )

    def add_tag(self, tag: dict[str, str]):
        """
        Add tag to the non-explicit clusters.

        Parameters:
        -----------
        tag: dict[str, str]
            The tag for each cluster with key as the cluster id and value as the tag.
        """
        # Create a mapping from cluster_id to tag
        cluster_to_tag = {}
        for cluster_id in self.cluster_df["cluster_id"].unique():
            cluster_to_tag[cluster_id] = tag.get(cluster_id, "")

        # Add the tag column
        self.cluster_df["tag"] = self.cluster_df["cluster_id"].map(cluster_to_tag)

    def export_clustering_result(self, output_file: Union[str, Path]):
        """
        Export the clustering result to a csv file.

        Parameters:
        -----------
        output_file: Union[str, Path]
            The path to the output file.
        """
        self.cluster_df.to_csv(output_file, index=False)


class ClusteringResultManager:
    """
    A class to manage the clustering results and generate metadata matrices.

    Attributes:
    -----------
    output_dir: Path
        The directory to store clustering results.
    clustering_sequence: list[str]
        The sequence of clustering IDs.
    cluster_id_manager: pd.DataFrame
        A DataFrame that maps unit IDs to cluster IDs across different clustering operations.
    cluster_labels_manager: pd.DataFrame
        A DataFrame that maps unit IDs to annotations and tags.
    summary: pd.DataFrame
        A combined DataFrame with all clustering information.
    """

    def __init__(self, output_dir: Union[str, Path]):
        """
        Initialize the clustering result manager.

        Parameters:
        -----------
        output_dir: Union[str, Path]
            The directory to store clustering results.
        """
        self.output_dir = Path(output_dir)
        # Create output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)
        # Create clustering results directory if it doesn't exist
        (self.output_dir / "clustering_results").mkdir(exist_ok=True)

        # Load clustering sequence if exists, otherwise initialize as empty list
        self.clustering_sequence_file = self.output_dir / "clustering_sequence.txt"
        if self.clustering_sequence_file.exists():
            with open(self.clustering_sequence_file, "r") as f:
                self.clustering_sequence = [line.strip() for line in f.readlines()]
        else:
            self.clustering_sequence = []

        # Initialize cluster_id_manager, cluster_labels_manager, and summary
        self.cluster_id_manager = pd.DataFrame()
        self.cluster_labels_manager = pd.DataFrame()
        self.summary = pd.DataFrame()

        # Load existing clustering results if any
        self._load_existing_clustering_results()

    def _load_existing_clustering_results(self):
        """
        Load existing clustering results from the output directory.
        """
        if not self.clustering_sequence:
            return

        # Initialize cluster_id_manager with unit_id column
        results_dir = self.output_dir / "clustering_results"

        # Create temporary DataFrames to hold all clustering results
        all_clustering_dfs = []

        # Load each clustering result
        for clustering_id in self.clustering_sequence:
            clustering_file = results_dir / f"{clustering_id}.csv"
            if not clustering_file.exists():
                continue

            # Load clustering result
            clustering_df = pd.read_csv(clustering_file)
            all_clustering_dfs.append(clustering_df)

        if not all_clustering_dfs:
            return

        # Combine all clustering DFs to get all unique unit_ids
        combined_df = pd.concat(all_clustering_dfs, ignore_index=True)
        all_unit_ids = combined_df["unit_id"].unique()

        # Initialize cluster_id_manager with unit_id column
        self.cluster_id_manager = pd.DataFrame({"unit_id": all_unit_ids})

        # Add clustering result columns to cluster_id_manager
        for clustering_id in self.clustering_sequence:
            clustering_file = results_dir / f"{clustering_id}.csv"
            if not clustering_file.exists():
                # If clustering result doesn't exist, add empty column
                self.cluster_id_manager[clustering_id] = ""
                continue

            # Load clustering result
            clustering_df = pd.read_csv(clustering_file)

            # Create a mapping from unit_id to cluster_id
            unit_to_cluster = dict(
                zip(clustering_df["unit_id"], clustering_df["cluster_id"])
            )

            # Add column for this clustering
            self.cluster_id_manager[clustering_id] = self.cluster_id_manager[
                "unit_id"
            ].map(lambda unit: unit_to_cluster.get(unit, ""))

        # Generate latest_cluster_id
        self._generate_latest_cluster_id()

        # Initialize cluster_labels_manager
        self._update_cluster_labels_manager()

        # Generate summary
        self._generate_summary()

    def _generate_latest_cluster_id(self):
        """
        Generate the latest cluster ID for each unit by concatenating all cluster IDs.
        """

        def concatenate_clusters(row):
            cluster_ids = []
            for clustering_id in self.clustering_sequence:
                if clustering_id in row and row[clustering_id]:
                    cluster_ids.append(str(row[clustering_id]))
            return "_".join(cluster_ids)

        self.cluster_id_manager["latest_cluster_id"] = self.cluster_id_manager.apply(
            concatenate_clusters, axis=1
        )

    def _update_cluster_labels_manager(self):
        """
        Update the cluster labels manager with the latest annotations and tags.
        """
        # Initialize cluster_labels_manager with unit_id and latest_cluster_id
        self.cluster_labels_manager = self.cluster_id_manager[
            ["unit_id", "latest_cluster_id"]
        ].copy()

        # Initialize annotation and tag columns
        self.cluster_labels_manager["annotation"] = ""
        self.cluster_labels_manager["tag"] = ""

        # Load the latest clustering result to get annotations and tags
        if self.clustering_sequence:
            results_dir = self.output_dir / "clustering_results"
            latest_clustering_id = self.clustering_sequence[-1]
            latest_clustering_file = results_dir / f"{latest_clustering_id}.csv"

            if latest_clustering_file.exists():
                latest_clustering_df = pd.read_csv(latest_clustering_file)

                # Check if annotation and tag columns exist
                if "annotation" in latest_clustering_df.columns:
                    # Create mapping from unit_id to annotation
                    unit_to_annotation = dict(
                        zip(
                            latest_clustering_df["unit_id"],
                            latest_clustering_df["annotation"],
                        )
                    )
                    self.cluster_labels_manager["annotation"] = (
                        self.cluster_labels_manager["unit_id"].map(
                            lambda unit: unit_to_annotation.get(unit, "")
                        )
                    )

                if "tag" in latest_clustering_df.columns:
                    # Create mapping from unit_id to tag
                    unit_to_tag = dict(
                        zip(
                            latest_clustering_df["unit_id"], latest_clustering_df["tag"]
                        )
                    )
                    self.cluster_labels_manager["tag"] = self.cluster_labels_manager[
                        "unit_id"
                    ].map(lambda unit: unit_to_tag.get(unit, ""))

    def _generate_summary(self):
        """
        Generate a summary DataFrame with all clustering information.
        """
        # Merge cluster_id_manager and cluster_labels_manager
        self.summary = pd.merge(
            self.cluster_id_manager,
            self.cluster_labels_manager[["unit_id", "annotation", "tag"]],
            on="unit_id",
            how="left",
        )

    def add_clustering_result(self, clustering_result: ClusteringResult):
        """
        Add a new clustering result.

        Parameters:
        -----------
        clustering_result: ClusteringResult
            The clustering result to add.
        """
        # Add the clustering_id to the clustering sequence
        if clustering_result.clustering_id not in self.clustering_sequence:
            self.clustering_sequence.append(clustering_result.clustering_id)

            # Update the clustering sequence file
            with open(self.clustering_sequence_file, "w") as f:
                for clustering_id in self.clustering_sequence:
                    f.write(f"{clustering_id}\n")

        # Save the clustering result
        results_dir = self.output_dir / "clustering_results"
        results_dir.mkdir(exist_ok=True)

        clustering_file = results_dir / f"{clustering_result.clustering_id}.csv"
        clustering_result.export_clustering_result(clustering_file)

        # Update the cluster_id_manager
        # Get all unit IDs
        all_unit_ids = (
            set(self.cluster_id_manager["unit_id"])
            if not self.cluster_id_manager.empty
            else set()
        )
        all_unit_ids.update(clustering_result.unit_id)

        # Initialize or update cluster_id_manager
        if self.cluster_id_manager.empty:
            self.cluster_id_manager = pd.DataFrame({"unit_id": list(all_unit_ids)})
        else:
            # Ensure all unit IDs are in cluster_id_manager
            missing_unit_ids = all_unit_ids - set(self.cluster_id_manager["unit_id"])
            if missing_unit_ids:
                new_rows = pd.DataFrame({"unit_id": list(missing_unit_ids)})
                self.cluster_id_manager = pd.concat(
                    [self.cluster_id_manager, new_rows], ignore_index=True
                )

        # Add column for this clustering
        unit_to_cluster = dict(
            zip(clustering_result.unit_id, clustering_result.cluster_id)
        )
        self.cluster_id_manager[clustering_result.clustering_id] = (
            self.cluster_id_manager["unit_id"].map(
                lambda unit: unit_to_cluster.get(unit, "")
            )
        )

        # Generate latest_cluster_id
        self._generate_latest_cluster_id()

        # Update cluster_labels_manager
        self._update_cluster_labels_manager()

        # Generate summary
        self._generate_summary()

    def export_metadata(self):
        """
        Export the metadata matrices (cluster_id_manager, cluster_labels_manager, summary).
        """
        self.cluster_id_manager.to_csv(
            self.output_dir / "cluster_id_manager.csv", index=False
        )
        self.cluster_labels_manager.to_csv(
            self.output_dir / "cluster_labels_manager.csv", index=False
        )
        self.summary.to_csv(self.output_dir / "summary.csv", index=False)


class SubClusterSystem:
    """
    A system to perform subclustering on data.

    Attributes:
    -----------
    raw_data: pd.DataFrame
        The raw data with unit_id as row index and feature as column index.
    output_dir: Path
        The directory to store clustering results.
    manager: ClusteringResultManager
        The manager to handle clustering results.
    """

    def __init__(self, raw_data: pd.DataFrame, output_dir: Union[str, Path]):
        """
        Initialize the subclustering system.

        Parameters:
        -----------
        raw_data: pd.DataFrame
            The raw data with unit_id as row index and feature as column index.
        output_dir: Union[str, Path]
            The directory to store clustering results.
        """
        self.raw_data = raw_data
        self.output_dir = Path(output_dir)
        self.manager = ClusteringResultManager(output_dir)

    def perform_clustering(
        self,
        unit_ids: list[str],
        features: list[str],
        method: str = "phenograph",
        method_params: Dict[str, Any] | None = None,
        annotations: Dict[str, str] | None = None,
        tags: Dict[str, str] | None = None,
    ):
        """
        Perform clustering on selected units and features.

        Parameters:
        -----------
        unit_ids: list[str]
            The IDs of units to cluster.
        features: list[str]
            The features to use for clustering.
        method: str, default="phenograph"
            The clustering method to use.
        method_params: Dict[str, Any] | None, default=None
            Parameters for the clustering method.
        annotations: Dict[str, str] | None, default=None
            Annotations for clusters (cluster_id -> annotation).
        tags: Dict[str, str] | None, default=None
            Tags for clusters (cluster_id -> tag).

        Returns:
        --------
        ClusteringResult
            The clustering result.
        """
        # Subset the raw data
        subset_data = self.raw_data.loc[unit_ids, features]

        # Generate a unique clustering ID
        clustering_id = str(uuid.uuid4())

        # Perform clustering based on the method
        if method == "phenograph":
            try:
                import scanpy as sc
                import scanpy.external as sce
            except ImportError:
                raise ImportError(
                    "scanpy is required for phenograph clustering. Install it with 'pip install scanpy'."
                )

            # Default parameters for phenograph
            if method_params is None:
                method_params = {"k": 30}

            # Create AnnData object
            adata = sc.AnnData(X=subset_data)

            # Run phenograph
            sce.tl.phenograph(adata, **method_params)

            # Get cluster assignments
            cluster_ids = [str(cid) for cid in adata.obs["phenograph"]]

        elif method == "kmeans":
            from sklearn.cluster import KMeans

            # Default parameters for kmeans
            if method_params is None:
                method_params = {"n_clusters": 8, "random_state": 0}

            # Run kmeans
            kmeans = KMeans(**method_params)
            kmeans.fit(subset_data)

            # Get cluster assignments
            cluster_ids = [str(cid) for cid in kmeans.labels_]

        elif method == "leiden":
            try:
                import scanpy as sc
            except ImportError:
                raise ImportError(
                    "scanpy is required for leiden clustering. Install it with 'pip install scanpy'."
                )

            # Default parameters for leiden
            if method_params is None:
                method_params = {"resolution": 1.0}

            # Create AnnData object
            adata = sc.AnnData(X=subset_data)

            # Compute neighborhood graph
            sc.pp.neighbors(adata)

            # Run leiden
            sc.tl.leiden(adata, **method_params)

            # Get cluster assignments
            cluster_ids = [str(cid) for cid in adata.obs["leiden"]]

        else:
            raise ValueError(f"Unsupported clustering method: {method}")

        # Create clustering result
        clustering_result = ClusteringResult(
            unit_id=unit_ids, cluster_id=cluster_ids, clustering_id=clustering_id
        )

        # Add annotations and tags if provided
        if annotations:
            clustering_result.add_annotation(annotations)

        if tags:
            clustering_result.add_tag(tags)

        # Add the clustering result to the manager
        self.manager.add_clustering_result(clustering_result)

        # Export metadata
        self.manager.export_metadata()

        return clustering_result

    def get_summary(self) -> pd.DataFrame:
        """
        Get the summary of all clustering results.

        Returns:
        --------
        pd.DataFrame
            The summary DataFrame.
        """
        return self.manager.summary

    def select_units_by_tag(self, tag: str) -> list[str]:
        """
        Select units by tag.

        Parameters:
        -----------
        tag: str
            The tag to select.

        Returns:
        --------
        list[str]
            The selected unit IDs.
        """
        if self.manager.cluster_labels_manager.empty:
            return []

        selected_units = self.manager.cluster_labels_manager[
            self.manager.cluster_labels_manager["tag"] == tag
        ]["unit_id"].tolist()

        return selected_units

    def select_units_by_annotation(self, annotation: str) -> list[str]:
        """
        Select units by annotation.

        Parameters:
        -----------
        annotation: str
            The annotation to select.

        Returns:
        --------
        list[str]
            The selected unit IDs.
        """
        if self.manager.cluster_labels_manager.empty:
            return []

        selected_units = self.manager.cluster_labels_manager[
            self.manager.cluster_labels_manager["annotation"] == annotation
        ]["unit_id"].tolist()

        return selected_units

    def select_units_by_latest_cluster_id(self, latest_cluster_id: str) -> list[str]:
        """
        Select units by latest cluster ID.

        Parameters:
        -----------
        latest_cluster_id: str
            The latest cluster ID to select.

        Returns:
        --------
        list[str]
            The selected unit IDs.
        """
        if self.manager.cluster_id_manager.empty:
            return []

        selected_units = self.manager.cluster_id_manager[
            self.manager.cluster_id_manager["latest_cluster_id"] == latest_cluster_id
        ]["unit_id"].tolist()

        return selected_units
