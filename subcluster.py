import uuid
from pathlib import Path
from typing import Any, Dict, Optional, Sequence, Tuple, Union

import anndata as ad
import pandas as pd
from pydantic import BaseModel, Field

# 1. clustering_sequence: record the sequence of clustering
# uuid_1, uuid_2, uuid_3, ...

# 2. clustering_result:
# Necessary fields:
# (1) clustering_id (uuid)
# (2) unit_id: id of the unit included in the clustering
# (3) cluster_id: id of the cluster assigned to the unit
# Optional fields:
# (4) annotation: annotation for the cluster (used for explicit clusters)
# (5) tag: tag for the cluster (used for non-explicit clusters)


# 3. cluster_id_manager:
# (1) unit_id: id of the unit included in the clustering
# (2) clustering results: one column for each clustering result, column name is
# the clustering id, value is the cluster id. Arrange the columns in the order of
# clustering_sequence.
# (3) latest_cluster_id: the latest cluster id for each unit, generated by
# concatenating the all cluster ids in the order of clustering_sequence.

# 4. cluster_labels_manager:
# (1) unit_id: id of the unit included in the clustering
# (2) annotation: annotation for the cluster (used for explicit clusters)
# (3) tag: tag for the cluster (used for non-explicit clusters)

# 5. summary: cluster_id_manager and cluster_label_manager
# (1) unit_id: id of the unit included in the clustering
# (2) clustering results: the clustering results of the unit, arranged in the
# order of clustering_sequence.
# (3) latest_cluster_id: the latest cluster id for each unit, generated by
# concatenating the all cluster ids in the order of clustering_sequence.
# (4) annotation: annotation for the latest cluster id (used for explicit clusters)
# (5) tag: tag for the latest cluster id (used for non-explicit clusters)


# File structure:
# output_dir/
#   clustering_sequence.txt: the sequence of clustering ids
#   clustering results/:
#     clustering_id_1.csv: the clustering result of the first clustering (unit_id,
#     cluster_id, annotation, tab_1, tab_2, ...)
#     clustering_id_2.csv: the clustering result of the second clustering

# Workflow:
# 1. Load the raw data (unit_id as row index, feature as column index)
# 2. Initialize the clustering result manager, load the clustering results from
#    the output_dir and map the cluster information to the raw data.
# 3. Subset the raw data based on the cluster information and perform subclustering.
# 4. Export the subclustering results to the output_dir.
# 5. Repeat the same workflow for the subclustering results.


class ClusteringResult(BaseModel):
    """
    A class to record the result of clustering and manage the annotation and tag.

    Attributes:
    -----------
    unit_id: list[str]
        The id of each unit included in the clustering.
    cluster_id: list[str]
        The cluster id assigned to each unit.
    clustering_id: str
        The id of the clustering.
    cluster_df: pd.DataFrame
        DataFrame to record the clustering result:
        - clustering_id: the id of the clustering process.
        - cell_id: the id of the unit.
        - cluster_id: the cluster id assigned to the unit.
        - annotation: the annotation for each cluster. If not specified, the
        cluster is non-explicit.
        - tag: the tag for each cluster. It is recommended to specify the tag for
        clusters with non-explicit annotation (mixed annotations), which makes it
        easier to select the non-explicit clusters for next clustering.
    """

    unit_id: list[str]
    cluster_id: list[str]
    clustering_id: str
    cluster_df: pd.DataFrame = Field(default_factory=pd.DataFrame)

    model_config = {"arbitrary_types_allowed": True}

    def __init__(self, **data):
        super().__init__(**data)
        self.cluster_df = pd.DataFrame(
            {
                "clustering_id": self.clustering_id,
                "unit_id": self.unit_id,
                "cluster_id": self.cluster_id,
            }
        )

    def add_annotation(self, annotation: dict[str, str]):
        """
        Add annotation to explicit clusters.

        Parameters:
        -----------
        annotation: dict[str, str]
            The annotation for each cluster with key as the cluster id and value as the annotation.
        """
        # Create a mapping from cluster_id to annotation
        cluster_to_annotation = {}
        for cluster_id in self.cluster_df["cluster_id"].unique():
            cluster_to_annotation[cluster_id] = annotation.get(cluster_id, "")

        # Add the annotation column
        self.cluster_df["annotation"] = self.cluster_df["cluster_id"].map(
            cluster_to_annotation
        )

    def add_tag(self, tag: dict[str, str]):
        """
        Add tag to the non-explicit clusters.

        Parameters:
        -----------
        tag: dict[str, str]
            The tag for each cluster with key as the cluster id and value as the tag.
        """
        # Create a mapping from cluster_id to tag
        cluster_to_tag = {}
        for cluster_id in self.cluster_df["cluster_id"].unique():
            cluster_to_tag[cluster_id] = tag.get(cluster_id, "")

        # Add the tag column
        self.cluster_df["tag"] = self.cluster_df["cluster_id"].map(cluster_to_tag)

    def export_clustering_result(self, output_file: Union[str, Path]):
        """
        Export the clustering result to a csv file.

        Parameters:
        -----------
        output_file: Union[str, Path]
            The path to the output file.
        """
        self.cluster_df.to_csv(output_file, index=False)


class ClusteringResultManager:
    """
    A class to manage the clustering results and generate metadata matrices.

    Attributes:
    -----------
    output_dir: Path
        The directory to store clustering results.
    clustering_sequence: list[str]
        The sequence of clustering IDs.
    cluster_id_manager: pd.DataFrame
        A DataFrame that maps unit IDs to cluster IDs across different clustering operations.
    cluster_labels_manager: pd.DataFrame
        A DataFrame that maps unit IDs to annotations and tags.
    summary: pd.DataFrame
        A combined DataFrame with all clustering information.
    """

    def __init__(self, output_dir: Union[str, Path]):
        """
        Initialize the clustering result manager.

        Parameters:
        -----------
        output_dir: Union[str, Path]
            The directory to store clustering results.
        """
        self.output_dir = Path(output_dir)
        # Create output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)
        # Create clustering results directory if it doesn't exist
        (self.output_dir / "clustering_results").mkdir(exist_ok=True)

        # Load clustering sequence if exists, otherwise initialize as empty list
        self.clustering_sequence_file = self.output_dir / "clustering_sequence.txt"
        if self.clustering_sequence_file.exists():
            with open(self.clustering_sequence_file, "r") as f:
                self.clustering_sequence = [line.strip() for line in f.readlines()]
        else:
            self.clustering_sequence = []

        # Initialize cluster_id_manager, cluster_labels_manager, and summary
        self.cluster_id_manager = pd.DataFrame()
        self.cluster_labels_manager = pd.DataFrame()
        self.summary = pd.DataFrame()

        # Load existing clustering results if any
        self._load_existing_clustering_results()

    def _load_existing_clustering_results(self):
        """
        Load existing clustering results from the output directory.
        """
        if not self.clustering_sequence:
            return

        # Initialize cluster_id_manager with unit_id column
        results_dir = self.output_dir / "clustering_results"

        # Create temporary DataFrames to hold all clustering results
        all_clustering_dfs = []

        # Load each clustering result
        for clustering_id in self.clustering_sequence:
            clustering_file = results_dir / f"{clustering_id}.csv"
            if not clustering_file.exists():
                continue

            # Load clustering result
            clustering_df = pd.read_csv(clustering_file)
            all_clustering_dfs.append(clustering_df)

        if not all_clustering_dfs:
            return

        # Combine all clustering DFs to get all unique unit_ids
        combined_df = pd.concat(all_clustering_dfs, ignore_index=True)
        all_unit_ids = combined_df["unit_id"].unique()

        # Initialize cluster_id_manager with unit_id column
        self.cluster_id_manager = pd.DataFrame({"unit_id": all_unit_ids})

        # Add clustering result columns to cluster_id_manager
        for clustering_id in self.clustering_sequence:
            clustering_file = results_dir / f"{clustering_id}.csv"
            if not clustering_file.exists():
                # If clustering result doesn't exist, add empty column
                self.cluster_id_manager[clustering_id] = ""
                continue

            # Load clustering result
            clustering_df = pd.read_csv(clustering_file)

            # Create a mapping from unit_id to cluster_id
            unit_to_cluster = dict(
                zip(clustering_df["unit_id"], clustering_df["cluster_id"])
            )

            # Add column for this clustering
            self.cluster_id_manager[clustering_id] = self.cluster_id_manager[
                "unit_id"
            ].map(lambda unit: unit_to_cluster.get(unit, ""))

        # Generate latest_cluster_id
        self._generate_latest_cluster_id()

        # Initialize cluster_labels_manager
        self._update_cluster_labels_manager()

        # Generate summary
        self._generate_summary()

    def _generate_latest_cluster_id(self):
        """
        Generate the latest cluster ID for each unit by concatenating all cluster IDs.
        """

        def concatenate_clusters(row):
            cluster_ids = []
            for clustering_id in self.clustering_sequence:
                if clustering_id in row and row[clustering_id]:
                    cluster_ids.append(str(row[clustering_id]))
            return "_".join(cluster_ids)

        self.cluster_id_manager["latest_cluster_id"] = self.cluster_id_manager.apply(
            concatenate_clusters, axis=1
        )

    def _update_cluster_labels_manager(self):
        """
        Update the cluster labels manager with the latest annotations and tags.
        """
        # Initialize cluster_labels_manager with unit_id and latest_cluster_id
        self.cluster_labels_manager = self.cluster_id_manager[
            ["unit_id", "latest_cluster_id"]
        ].copy()

        # Initialize annotation and tag columns
        self.cluster_labels_manager["annotation"] = ""
        self.cluster_labels_manager["tag"] = ""

        # Load the latest clustering result to get annotations and tags
        if self.clustering_sequence:
            results_dir = self.output_dir / "clustering_results"
            latest_clustering_id = self.clustering_sequence[-1]
            latest_clustering_file = results_dir / f"{latest_clustering_id}.csv"

            if latest_clustering_file.exists():
                latest_clustering_df = pd.read_csv(latest_clustering_file)

                # Check if annotation and tag columns exist
                if "annotation" in latest_clustering_df.columns:
                    # Create mapping from unit_id to annotation
                    unit_to_annotation = dict(
                        zip(
                            latest_clustering_df["unit_id"],
                            latest_clustering_df["annotation"],
                        )
                    )
                    self.cluster_labels_manager["annotation"] = (
                        self.cluster_labels_manager["unit_id"].map(
                            lambda unit: unit_to_annotation.get(unit, "")
                        )
                    )

                if "tag" in latest_clustering_df.columns:
                    # Create mapping from unit_id to tag
                    unit_to_tag = dict(
                        zip(
                            latest_clustering_df["unit_id"], latest_clustering_df["tag"]
                        )
                    )
                    self.cluster_labels_manager["tag"] = self.cluster_labels_manager[
                        "unit_id"
                    ].map(lambda unit: unit_to_tag.get(unit, ""))

    def _generate_summary(self):
        """
        Generate a summary DataFrame with all clustering information.
        """
        # Merge cluster_id_manager and cluster_labels_manager
        self.summary = pd.merge(
            self.cluster_id_manager,
            self.cluster_labels_manager[["unit_id", "annotation", "tag"]],
            on="unit_id",
            how="left",
        )

    def add_clustering_result(self, clustering_result: ClusteringResult):
        """
        Add a new clustering result.

        Parameters:
        -----------
        clustering_result: ClusteringResult
            The clustering result to add.
        """
        # Add the clustering_id to the clustering sequence
        if clustering_result.clustering_id not in self.clustering_sequence:
            self.clustering_sequence.append(clustering_result.clustering_id)

            # Update the clustering sequence file
            with open(self.clustering_sequence_file, "w") as f:
                for clustering_id in self.clustering_sequence:
                    f.write(f"{clustering_id}\n")

        # Save the clustering result
        results_dir = self.output_dir / "clustering_results"
        results_dir.mkdir(exist_ok=True)

        clustering_file = results_dir / f"{clustering_result.clustering_id}.csv"
        clustering_result.export_clustering_result(clustering_file)

        # Update the cluster_id_manager
        # Get all unit IDs
        all_unit_ids = (
            set(self.cluster_id_manager["unit_id"])
            if not self.cluster_id_manager.empty
            else set()
        )
        all_unit_ids.update(clustering_result.unit_id)

        # Initialize or update cluster_id_manager
        if self.cluster_id_manager.empty:
            self.cluster_id_manager = pd.DataFrame({"unit_id": list(all_unit_ids)})
        else:
            # Ensure all unit IDs are in cluster_id_manager
            missing_unit_ids = all_unit_ids - set(self.cluster_id_manager["unit_id"])
            if missing_unit_ids:
                new_rows = pd.DataFrame({"unit_id": list(missing_unit_ids)})
                self.cluster_id_manager = pd.concat(
                    [self.cluster_id_manager, new_rows], ignore_index=True
                )

        # Add column for this clustering
        unit_to_cluster = dict(
            zip(clustering_result.unit_id, clustering_result.cluster_id)
        )
        self.cluster_id_manager[clustering_result.clustering_id] = (
            self.cluster_id_manager["unit_id"].map(
                lambda unit: unit_to_cluster.get(unit, "")
            )
        )

        # Generate latest_cluster_id
        self._generate_latest_cluster_id()

        # Update cluster_labels_manager
        self._update_cluster_labels_manager()

        # Generate summary
        self._generate_summary()

    def export_metadata(self):
        """
        Export the metadata matrices (cluster_id_manager, cluster_labels_manager, summary).
        """
        self.cluster_id_manager.to_csv(
            self.output_dir / "cluster_id_manager.csv", index=False
        )
        self.cluster_labels_manager.to_csv(
            self.output_dir / "cluster_labels_manager.csv", index=False
        )
        self.summary.to_csv(self.output_dir / "summary.csv", index=False)


class SubClusterSystem:
    """
    A system to perform subclustering on data.

    Attributes:
    -----------
    raw_data: pd.DataFrame
        The raw data with unit_id as row index and feature as column index.
    output_dir: Path
        The directory to store clustering results.
    manager: ClusteringResultManager
        The manager to handle clustering results.
    adata: ad.AnnData, optional
        The AnnData object if provided during initialization.
    """

    def __init__(
        self, data: Union[pd.DataFrame, ad.AnnData], output_dir: Union[str, Path]
    ):
        """
        Initialize the subclustering system.

        Parameters:
        -----------
        data: Union[pd.DataFrame, ad.AnnData]
            The data with unit_id as row index and feature as column index.
            Can be either pandas DataFrame or AnnData object.
        output_dir: Union[str, Path]
            The directory to store clustering results.
        """
        if isinstance(data, ad.AnnData):
            self.adata = data
            self.raw_data = data.to_df()  # Convert to DataFrame for compatibility
        else:
            self.raw_data = data
            self.adata = None

        self.output_dir = Path(output_dir)
        self.manager = ClusteringResultManager(output_dir)

        # Store last method and params for reference
        self._last_method = None
        self._last_params = None

    def perform_clustering(
        self,
        unit_ids: list[str],
        features: list[str],
        method: str = "phenograph",
        method_params: Dict[str, Any] | None = None,
        create_adata: bool = False,
    ) -> Union[ClusteringResult, Tuple[ClusteringResult, ad.AnnData]]:
        """
        Perform clustering on selected units and features.

        Parameters:
        -----------
        unit_ids: list[str]
            The IDs of units to cluster.
        features: list[str]
            The features to use for clustering.
        method: str, default="phenograph"
            The clustering method to use.
        method_params: Dict[str, Any] | None, default=None
            Parameters for the clustering method.
        create_adata: bool, default=False
            Whether to create and return a subset AnnData object with clustering results.

        Returns:
        --------
        Union[ClusteringResult, Tuple[ClusteringResult, ad.AnnData]]
            If create_adata=True, returns (ClusteringResult, AnnData), otherwise just ClusteringResult.
        """
        # Store method info for reference
        self._last_method = method
        self._last_params = method_params

        # Subset the raw data
        subset_data = self.raw_data.loc[unit_ids, features]

        # Generate a unique clustering ID
        clustering_id = str(uuid.uuid4())

        # Perform clustering based on the method
        if method == "phenograph":
            cluster_ids = self._run_phenograph_clustering(subset_data, method_params)
        elif method == "kmeans":
            cluster_ids = self._run_kmeans_clustering(subset_data, method_params)
        elif method == "leiden":
            cluster_ids = self._run_leiden_clustering(subset_data, method_params)
        else:
            raise ValueError(f"Unsupported clustering method: {method}")

        # Create clustering result
        clustering_result = ClusteringResult(
            unit_id=unit_ids, cluster_id=cluster_ids, clustering_id=clustering_id
        )

        # Create AnnData if requested
        if create_adata and self.adata is not None:
            adata_subset = self.create_subclustering_adata(unit_ids, features)
            adata_subset = self.add_clustering_to_adata(adata_subset, clustering_result)
            return clustering_result, adata_subset

        return clustering_result

    def create_subclustering_adata(
        self, unit_ids: list[str], features: Optional[Sequence[str]] = None
    ) -> ad.AnnData:
        """
        Create a subset AnnData object for subclustering.

        Parameters:
        -----------
        unit_ids: list[str]
            The IDs of units to include in the subset.
        features: Optional[Sequence[str]], optional
            Features to include. If None, all features are included.

        Returns:
        --------
        ad.AnnData
            A subset AnnData object containing only the specified units and features.
        """
        if self.adata is None:
            raise ValueError(
                "No AnnData object available. Please initialize with an AnnData object."
            )

        # Filter by unit_ids
        valid_ids = [id for id in unit_ids if id in self.adata.obs_names]
        if not valid_ids:
            raise ValueError(
                "None of the specified unit_ids exist in the AnnData object."
            )

        # AnnData supports list indexing
        adata_subset = self.adata[valid_ids].copy()

        # Filter by features if specified
        if features is not None:
            valid_features = [f for f in features if f in adata_subset.var_names]
            if not valid_features:
                raise ValueError("None of the specified features exist in the data.")
            # AnnData supports list indexing for features
            adata_subset = adata_subset[:, valid_features]

        return adata_subset

    def add_clustering_to_adata(
        self,
        adata: ad.AnnData,
        clustering_result: ClusteringResult,
        cluster_name: Optional[str] = None,
    ) -> ad.AnnData:
        """
        Add clustering results to an AnnData object.

        Parameters:
        -----------
        adata: ad.AnnData
            The AnnData object to add clustering results to.
        clustering_result: ClusteringResult
            The clustering result to add.
        cluster_name: Optional[str], optional
            Name for the clustering column. If None, uses a shortened clustering ID.

        Returns:
        --------
        ad.AnnData
            The updated AnnData object.
        """
        # Create a mapping from unit_id to cluster_id
        unit_to_cluster = dict(
            zip(clustering_result.unit_id, clustering_result.cluster_id)
        )

        # Determine cluster column name
        if cluster_name is None:
            cluster_name = f"cluster_{clustering_result.clustering_id[:8]}"

        # Add cluster IDs to obs
        adata.obs[cluster_name] = [
            unit_to_cluster.get(unit, "NA") for unit in adata.obs_names
        ]
        adata.obs[cluster_name] = adata.obs[cluster_name].astype("category")

        # Add annotations if available
        if "annotation" in clustering_result.cluster_df.columns:
            # Create mapping from cluster_id to annotation
            cluster_to_anno = {}
            for cid in clustering_result.cluster_df["cluster_id"].unique():
                mask = clustering_result.cluster_df["cluster_id"] == cid
                if any(mask):
                    anno_series = clustering_result.cluster_df.loc[mask, "annotation"]
                    if not anno_series.empty:
                        anno = anno_series.iloc[0]
                        cluster_to_anno[cid] = anno

            # Add annotations
            anno_col = f"{cluster_name}_annotation"
            adata.obs[anno_col] = [
                cluster_to_anno.get(adata.obs[cluster_name][i], "")
                if adata.obs[cluster_name][i] != "NA"
                else ""
                for i in range(len(adata.obs))
            ]

        # Add tags if available
        if "tag" in clustering_result.cluster_df.columns:
            # Create mapping from cluster_id to tag
            cluster_to_tag = {}
            for cid in clustering_result.cluster_df["cluster_id"].unique():
                mask = clustering_result.cluster_df["cluster_id"] == cid
                if any(mask):
                    tag_series = clustering_result.cluster_df.loc[mask, "tag"]
                    if not tag_series.empty:
                        tag = tag_series.iloc[0]
                        cluster_to_tag[cid] = tag

            # Add tags
            tag_col = f"{cluster_name}_tag"
            adata.obs[tag_col] = [
                cluster_to_tag.get(adata.obs[cluster_name][i], "")
                if adata.obs[cluster_name][i] != "NA"
                else ""
                for i in range(len(adata.obs))
            ]

        # Store clustering parameters in uns
        adata.uns[f"{cluster_name}_params"] = {
            "clustering_id": clustering_result.clustering_id,
            "method": self._last_method,
            "method_params": self._last_params,
            "n_clusters": len(set(clustering_result.cluster_id)),
        }

        return adata

    def _run_phenograph_clustering(
        self, data: pd.DataFrame, method_params: Dict[str, Any] | None = None
    ):
        """
        Run phenograph clustering on the data.

        Parameters:
        -----------
        data: pd.DataFrame
            Data to cluster.
        method_params: Dict[str, Any] | None
            Parameters for phenograph clustering.

        Returns:
        --------
        list[str]
            Cluster assignments.
        """
        try:
            import scanpy as sc
            import scanpy.external as sce
        except ImportError:
            raise ImportError(
                "scanpy is required for phenograph clustering. Install it with 'pip install scanpy'."
            )

        # Default parameters for phenograph
        if method_params is None:
            method_params = {"k": 30}

        # Create AnnData object
        adata = sc.AnnData(X=data)

        # Run phenograph
        sc.pp.pca(adata)
        sce.tl.phenograph(adata, **method_params)

        # Get cluster assignments
        col_cluster = [col for col in adata.obs.columns if "pheno" in col][0]
        cluster_ids = [str(cid) for cid in adata.obs[col_cluster]]

        return cluster_ids

    def _run_kmeans_clustering(
        self, data: pd.DataFrame, method_params: Dict[str, Any] | None = None
    ):
        """
        Run kmeans clustering on the data.

        Parameters:
        -----------
        data: pd.DataFrame
            Data to cluster.
        method_params: Dict[str, Any] | None
            Parameters for kmeans clustering.

        Returns:
        --------
        list[str]
            Cluster assignments.
        """
        from sklearn.cluster import KMeans

        # Default parameters for kmeans
        if method_params is None:
            method_params = {"n_clusters": 8, "random_state": 0}

        # Run kmeans
        kmeans = KMeans(**method_params)
        kmeans.fit(data)

        # Get cluster assignments
        cluster_ids = [str(cid) for cid in kmeans.labels_]

        return cluster_ids

    def _run_leiden_clustering(
        self, data: pd.DataFrame, method_params: Dict[str, Any] | None = None
    ):
        """
        Run leiden clustering on the data.

        Parameters:
        -----------
        data: pd.DataFrame
            Data to cluster.
        method_params: Dict[str, Any] | None
            Parameters for leiden clustering.

        Returns:
        --------
        list[str]
            Cluster assignments.
        """
        try:
            import scanpy as sc
        except ImportError:
            raise ImportError(
                "scanpy is required for leiden clustering. Install it with 'pip install scanpy'."
            )

        # Default parameters for leiden
        if method_params is None:
            method_params = {"resolution": 1.0}

        # Create AnnData object
        adata = sc.AnnData(X=data)

        # Compute neighborhood graph
        sc.pp.neighbors(adata)

        # Run leiden
        sc.tl.leiden(adata, **method_params)

        # Get cluster assignments
        cluster_ids = [str(cid) for cid in adata.obs["leiden"]]

        return cluster_ids

    def add_annotations_to_clustering(
        self, clustering_result: ClusteringResult, annotations: Dict[str, str]
    ):
        """
        Add annotations to clusters.

        Parameters:
        -----------
        clustering_result: ClusteringResult
            The clustering result to annotate.
        annotations: Dict[str, str]
            Annotations for clusters (cluster_id -> annotation).
        """
        clustering_result.add_annotation(annotations)
        return clustering_result

    def add_tags_to_clustering(
        self, clustering_result: ClusteringResult, tags: Dict[str, str]
    ):
        """
        Add tags to clusters.

        Parameters:
        -----------
        clustering_result: ClusteringResult
            The clustering result to tag.
        tags: Dict[str, str]
            Tags for clusters (cluster_id -> tag).
        """
        clustering_result.add_tag(tags)
        return clustering_result

    def save_clustering_result(self, clustering_result: ClusteringResult):
        """
        Save the clustering result and export metadata.

        Parameters:
        -----------
        clustering_result: ClusteringResult
            The clustering result to save.
        """
        # Add the clustering result to the manager
        self.manager.add_clustering_result(clustering_result)

        # Export metadata
        self.manager.export_metadata()

    def get_summary(self) -> pd.DataFrame:
        """
        Get the summary of all clustering results.

        Returns:
        --------
        pd.DataFrame
            The summary DataFrame.
        """
        return self.manager.summary

    def select_units_by_tag(self, tag: str) -> list[str]:
        """
        Select units by tag.

        Parameters:
        -----------
        tag: str
            The tag to select.

        Returns:
        --------
        list[str]
            The selected unit IDs.
        """
        if self.manager.cluster_labels_manager.empty:
            return []

        selected_units = self.manager.cluster_labels_manager[
            self.manager.cluster_labels_manager["tag"] == tag
        ]["unit_id"].tolist()

        return selected_units

    def select_units_by_annotation(self, annotation: str) -> list[str]:
        """
        Select units by annotation.

        Parameters:
        -----------
        annotation: str
            The annotation to select.

        Returns:
        --------
        list[str]
            The selected unit IDs.
        """
        if self.manager.cluster_labels_manager.empty:
            return []

        selected_units = self.manager.cluster_labels_manager[
            self.manager.cluster_labels_manager["annotation"] == annotation
        ]["unit_id"].tolist()

        return selected_units

    def select_units_by_latest_cluster_id(self, latest_cluster_id: str) -> list[str]:
        """
        Select units by latest cluster ID.

        Parameters:
        -----------
        latest_cluster_id: str
            The latest cluster ID to select.

        Returns:
        --------
        list[str]
            The selected unit IDs.
        """
        if self.manager.cluster_id_manager.empty:
            return []

        selected_units = self.manager.cluster_id_manager[
            self.manager.cluster_id_manager["latest_cluster_id"] == latest_cluster_id
        ]["unit_id"].tolist()

        return selected_units
